use std::{str::FromStr, time::Duration};

use alloy::{primitives::Address as StrataAddress, providers::WalletProvider};
use argh::FromArgs;
use bdk_wallet::{
    bitcoin::{hashes::Hash, taproot::LeafVersion, Address, TapNodeHash, XOnlyPublicKey},
    chain::ChainOracle,
    descriptor::IntoWalletDescriptor,
    miniscript::{miniscript::Tap, Miniscript},
    template::DescriptorTemplateOut,
    KeychainKind, TxOrdering, Wallet,
};
use console::{style, Term};
use indicatif::ProgressBar;
use strata_bridge_tx_builder::constants::MAGIC_BYTES;

use crate::{
    constants::{
        BRIDGE_IN_AMOUNT, L2_BLOCK_TIME, NETWORK, RECOVER_AT_DELAY, RECOVER_DELAY, UNSPENDABLE,
    },
    recovery::DescriptorRecovery,
    seed::Seed,
    settings::Settings,
    signet::{get_fee_rate, log_fee_rate, EsploraClient, SignetWallet},
    strata::StrataWallet,
    taproot::{ExtractP2trPubkey, NotTaprootAddress},
};

/// Bridge 10 BTC from signet to Strata. If an address is not provided, the wallet's internal
/// Strata address will be used.
#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "bridge-in")]
pub struct BridgeInArgs {
    #[argh(positional)]
    strata_address: Option<String>,
}

pub async fn bridge_in(args: BridgeInArgs, seed: Seed, settings: Settings, esplora: EsploraClient) {
    let term = Term::stdout();
    let requested_strata_address = args
        .strata_address
        .map(|a| StrataAddress::from_str(&a).expect("bad strata address"));
    let mut l1w = SignetWallet::new(&seed, NETWORK).unwrap();
    let l2w = StrataWallet::new(&seed, &settings.l2_http_endpoint).unwrap();

    l1w.sync(&esplora).await.unwrap();
    let recovery_address = l1w.reveal_next_address(KeychainKind::External).address;
    l1w.persist().unwrap();

    let strata_address = requested_strata_address.unwrap_or(l2w.default_signer_address());
    let _ = term.write_line(&format!(
        "Bridging {} to Strata address {}",
        style(BRIDGE_IN_AMOUNT.to_string()).green(),
        style(strata_address).cyan(),
    ));

    let _ = term.write_line(&format!(
        "Recovery address: {}",
        style(recovery_address.to_string()).yellow()
    ));

    let (bridge_in_desc, recovery_script_hash) =
        bridge_in_descriptor(settings.bridge_musig2_pubkey, recovery_address)
            .expect("valid bridge in descriptor");

    let desc = bridge_in_desc
        .clone()
        .into_wallet_descriptor(l1w.secp_ctx(), NETWORK)
        .expect("valid descriptor");

    let mut temp_wallet = Wallet::create_single(desc.clone())
        .network(NETWORK)
        .create_wallet_no_persist()
        .expect("valid wallet");

    let current_block_height = l1w
        .local_chain()
        .get_chain_tip()
        .expect("valid chain tip")
        .height;

    let recover_at = current_block_height + RECOVER_AT_DELAY;

    let bridge_in_address = temp_wallet
        .reveal_next_address(KeychainKind::External)
        .address;

    let _ = term.write_line(&format!(
        "Using {} as bridge in address",
        style(bridge_in_address.to_string()).yellow()
    ));

    let fee_rate = get_fee_rate(1, &esplora)
        .await
        .expect("should get fee rate")
        .expect("should have valid fee rate");

    log_fee_rate(&term, &fee_rate);

    const MBL: usize = MAGIC_BYTES.len();
    const TNHL: usize = TapNodeHash::LEN;
    let mut op_return_data = [0u8; MBL + TNHL + StrataAddress::len_bytes()];
    op_return_data[..MBL].copy_from_slice(MAGIC_BYTES);
    op_return_data[MBL..MBL + TNHL]
        .copy_from_slice(recovery_script_hash.as_raw_hash().as_byte_array());
    op_return_data[MBL + TNHL..].copy_from_slice(strata_address.as_slice());

    let mut psbt = l1w
        .build_tx()
        // Important: the deposit won't be found by the sequencer if the order isn't correct.
        .ordering(TxOrdering::Untouched)
        .add_recipient(bridge_in_address.script_pubkey(), BRIDGE_IN_AMOUNT)
        .add_data(&op_return_data)
        .fee_rate(fee_rate)
        .clone()
        .finish()
        .expect("valid psbt");
    l1w.sign(&mut psbt, Default::default()).unwrap();
    let _ = term.write_line("Built transaction");

    let tx = psbt.extract_tx().expect("valid tx");

    let pb = ProgressBar::new_spinner().with_message("Saving output descriptor");
    pb.enable_steady_tick(Duration::from_millis(100));

    let mut desc_file = DescriptorRecovery::open(&seed, &settings.descriptor_db)
        .await
        .unwrap();
    desc_file
        .add_desc(recover_at, &bridge_in_desc)
        .await
        .unwrap();
    pb.finish_with_message("Saved output descriptor");

    let pb = ProgressBar::new_spinner().with_message("Broadcasting transaction");
    pb.enable_steady_tick(Duration::from_millis(100));
    esplora.broadcast(&tx).await.expect("successful broadcast");
    pb.finish_with_message(format!("Transaction {} broadcasted", tx.compute_txid()));
    let _ = term.write_line(&format!(
        "Expect transaction confirmation in ~{:?}. Funds will take longer than this to be available on Strata.",
        L2_BLOCK_TIME
    ));
}

fn bridge_in_descriptor(
    bridge_pubkey: XOnlyPublicKey,
    recovery_address: Address,
) -> Result<(DescriptorTemplateOut, TapNodeHash), NotTaprootAddress> {
    let recovery_xonly_pubkey = recovery_address.extract_p2tr_pubkey()?;

    let desc = bdk_wallet::descriptor!(
        tr(UNSPENDABLE, {
            pk(bridge_pubkey),
            and_v(v:pk(recovery_xonly_pubkey),older(RECOVER_DELAY))
        })
    )
    .expect("valid descriptor");

    // we have to do this to obtain the script hash
    // i have tried to extract it directly from the desc above
    // it is a massive pita
    let recovery_script = Miniscript::<XOnlyPublicKey, Tap>::from_str(&format!(
        "and_v(v:pk({}),older(1008))",
        recovery_xonly_pubkey
    ))
    .expect("valid recovery script")
    .encode();

    let recovery_script_hash = TapNodeHash::from_script(&recovery_script, LeafVersion::TapScript);

    Ok((desc, recovery_script_hash))
}
