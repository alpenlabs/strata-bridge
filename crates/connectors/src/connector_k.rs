//! This connector is used to connect the Kickoff and Claim transactions.
// FIXME: remove this once the stake chain is integrated.
use bitcoin::{
    psbt::Input,
    taproot::{ControlBlock, LeafVersion},
    Address, Network, ScriptBuf,
};
use bitvm::{
    signatures::wots_api::{wots256, SignatureImpl},
    treepp::*,
};
use strata_bridge_primitives::{scripts::prelude::*, wots};

/// Connector between the Kickoff and Claim transactions.
///
/// # NOTE: This will be replaced by the stake chain connector.
#[derive(Debug, Clone)]
pub struct ConnectorK {
    /// The bitcoin network for the addresses generated by the connector.
    network: Network,

    /// The WOTS public key used for bitcommitment scripts.
    claim_bitcommitment: wots::Wots256PublicKey,
}

impl ConnectorK {
    /// Constructs a new connector.
    pub const fn new(network: Network, withdrawal_fulfillment_pk: wots::Wots256PublicKey) -> Self {
        Self {
            network,
            claim_bitcommitment: withdrawal_fulfillment_pk,
        }
    }

    fn create_locking_script(&self) -> ScriptBuf {
        let wots::Wots256PublicKey(withdrawal_fulfillment_pk) = &self.claim_bitcommitment;

        script! {
            // bridge_out_tx_id
            { wots256::checksig_verify(**withdrawal_fulfillment_pk) }

            for _ in 0..256/4 { OP_DROP } // drop data (in nibbles) from stack

            OP_TRUE
        }
        .compile()
    }

    /// Creates a taproot address for the connector corresponding to the locking script.
    pub fn create_taproot_address(&self) -> Address {
        let scripts = &[self.create_locking_script()];

        let (taproot_address, _) =
            create_taproot_addr(&self.network, SpendPath::ScriptSpend { scripts })
                .expect("should be able to add scripts");

        taproot_address
    }

    /// Generates the taproot spend info for the connector.
    pub fn generate_spend_info(&self) -> (ScriptBuf, ControlBlock) {
        let script = self.create_locking_script();

        let (_, spend_info) = create_taproot_addr(
            &self.network,
            SpendPath::ScriptSpend {
                scripts: &[script.clone()],
            },
        )
        .expect("should be able to create taproot address");

        let control_block = spend_info
            .control_block(&(script.clone(), LeafVersion::TapScript))
            .expect("script must be part of the address");

        (script, control_block)
    }

    /// Finalizes the input to the transaction that spends this connector.
    pub fn finalize_input(&self, input: &mut Input, signature: wots256::Signature) {
        let witness = script! {
            { signature.to_script() }
        };

        let result = execute_script(witness.clone());
        let mut witness_stack = (0..result.final_stack.len())
            .map(|index| result.final_stack.get(index))
            .collect::<Vec<_>>();

        let (script, control_block) = self.generate_spend_info();

        witness_stack.push(script.to_bytes());
        witness_stack.push(control_block.serialize());

        finalize_input(input, witness_stack);
    }
}
