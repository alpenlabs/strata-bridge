//! Subset of strata RPCs for the bridge.

use jsonrpsee::{core::RpcResult, proc_macros::rpc};
use strata_bridge_primitives::{
    duties::BridgeDuties,
    types::{OperatorIdx, PublickeyTable},
};
use strata_rpc_types::{ClientStatus, L1Status, RpcCheckpointInfo};

#[cfg_attr(not(feature = "client"), rpc(server, namespace = "strata"))]
#[cfg_attr(feature = "client", rpc(server, client, namespace = "strata"))]
pub trait StrataApi {
    #[method(name = "l1status")]
    async fn get_l1_status(&self) -> RpcResult<L1Status>;

    #[method(name = "getL1blockHash")]
    async fn get_l1_block_hash(&self, height: u64) -> RpcResult<Option<String>>;

    #[method(name = "clientStatus")]
    async fn get_client_status(&self) -> RpcResult<ClientStatus>;

    /// Get the [`BridgeDuties`] from a certain `start_index` for a given [`OperatorIdx`].
    ///
    /// The `start_index` is a monotonically increasing number with no gaps. So, it is safe to call
    /// this method with any `u64` value. If an entry corresponding to the `start_index` is not
    /// found, an empty list is returned.
    #[method(name = "getBridgeDuties")]
    async fn get_bridge_duties(
        &self,
        operator_idx: OperatorIdx,
        start_index: u64,
    ) -> RpcResult<BridgeDuties>;

    /// Get the operators' public key table that is used to sign transactions and messages.
    ///
    /// # Note
    ///
    /// The rollup chain state only has the [`XOnlyPublicKey`](bitcoin::secp256k1::XOnlyPublicKey).
    /// The [`PublicKey`](bitcoin::secp256k1::PublicKey) in the [`PublickeyTable`] is generated by
    /// assuming an even parity as per the final schema in [`BIP 340`](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#design)
    #[method(name = "getActiveOperatorChainPubkeySet")]
    async fn get_active_operator_chain_pubkey_set(&self) -> RpcResult<PublickeyTable>;

    /// Get latest checkpoint info
    #[method(name = "getLatestCheckpointIndex")]
    async fn get_latest_checkpoint_index(&self, finalized: Option<bool>) -> RpcResult<Option<u64>>;

    /// Get nth checkpoint info if any
    #[method(name = "getCheckpointInfo")]
    async fn get_checkpoint_info(&self, idx: u64) -> RpcResult<Option<RpcCheckpointInfo>>;
}
